# 추상화 중심 사고: 행동 전략으로서의 설계

## 이론적 배경: 켄트 벡의 Tidy First?

이 문서의 사고방식은 켄트 벡의 "Tidy First?(2023)"와 깊이 연결되어 있다.

### 켄트 벡의 핵심 문장

**"Software design is an exercise in human relationships."**

코드는 컴퓨터만 읽는 게 아니라 사람이 읽는다. 설계는 기술 문제가 아니라 사람 사이의 관계 문제다. 이것이 이 문서에서 말하는 "덜컥거림 없이 읽히는가"의 이론적 근거다.

**AI 시대의 확장: Human + AI Relationships**

오늘날 이 문장은 확장되어야 한다. 코드를 읽는 건 사람만이 아니다.

```
덜컥거림 없이 읽히는 코드
├─ 사람이 읽기 쉽다
├─ 3개월 후의 내가 읽기 쉽다
├─ 팀원이 읽기 쉽다
└─ AI가 읽기 쉽다 ← 새로운 차원
```

AI와 협업할 때, 좋은 추상화는 더욱 중요해진다:

- **컨텍스트 윈도우의 한계**: AI는 한 번에 볼 수 있는 코드 양이 제한되어 있다. 잘 추상화된 코드는 AI가 필요한 맥락만 보고도 이해할 수 있게 한다.
- **명확한 인터페이스**: `<결제창 결제수단={토스페이} />`는 AI가 "결제창은 결제수단을 받는다"를 즉시 파악할 수 있다. 통로로서의 props는 AI도 혼란스럽게 만든다.
- **변경 지점의 명확성**: AI에게 수정을 요청할 때, 추상화 경계가 명확하면 "어디를 건드려야 하는지"가 분명해진다.

결국 **좋은 추상화는 사람의 인지부하를 낮추는 동시에 AI의 인지부하도 낮춘다.** 둘은 같은 방향이다. 사람이 읽기 어려운 코드는 AI도 읽기 어렵고, 사람이 읽기 쉬운 코드는 AI도 읽기 쉽다.

### One Pile: 가장 중요한 개념

켄트 벡의 15가지 tidying 중 가장 반직관적이면서 핵심적인 것:

```
"Tidy First has a bias toward lots of little pieces...
Sometimes, though, this process goes wrong. Because of how
the small pieces interact, the code is harder to understand.

To regain clarity, the code must first be mooshed together
so new, easier-to-understand parts can then be extracted."

"Inline as much of the code as you need until it's all in
one big pile. Tidy from there."
```

**"먼저 하나로 뭉쳐라, 그 다음에 다시 추출하라"**

이게 이 문서의 "펼쳐놓기"와 정확히 같은 개념이다:

```
Tidy First:  One Pile → 이해 → 새로운 조각으로 추출
이 문서:     펼쳐놓기 → 관찰 → 패턴 발견 → 추출
```

### Coupling과 Cohesion의 재정의

켄트 벡은 Yourdon & Constantine(1975)의 원래 정의로 돌아간다:

```
Coupling: 하나를 바꾸면 다른 것도 바꿔야 하는 관계
         (특정 변경에 대해 정의됨)

Cohesion: 커플링의 잠재적 확산을 제한하는 것
         "sweep it all into one pile"
```

**"Cohesion은 커플링을 한 곳으로 쓸어 담는 것이다."**

이건 이 문서의 "추상화의 경계에서 변경이 잘 막히는가"와 같은 개념이다.

### "중복은 제거하는 것이 아니라 발견하는 것이다"

켄트 벡의 핵심 통찰:

```
잘못된 해석: 중복을 보면 즉시 제거하라
올바른 해석: 중복을 발견하면, 그게 진짜 같은 아이디어인지 확인하고,
           그렇다면 추상화하라
```

이건 이 문서의 "우연의 일치 vs 본질적 동일" 검증과 정확히 일치한다. 그리고 이 문서 전체를 관통하는 핵심 통찰이기도 하다:

```
중복:   발견하는 것 (O)  /  제거하는 것 (X)
패턴:   발견을 표현 (O)  /  규칙으로 적용 (X)
추상화: 관찰 후 추출 (O)  /  사전 설계 (X)
```

### First, After, Later, Never

켄트 벡은 "언제 정리할 것인가"에 대한 실용적 가이드를 제시한다:

```
First:  정리하면 변경이 쉬워질 때
After:  변경 후 정리할 시간이 있을 때
Later:  지금은 아니지만 언젠가
Never:  다시 안 건드릴 코드
```

### 이 문서가 Tidy First?에 추가하는 것

Tidy First?는 "무엇을(Tidyings)"과 "언제(First/After/Later/Never)"를 잘 다루지만, **"어떻게 발견하는가"**에 대한 감각적 가이드는 덜 명시적이다.

```
Tidy First?: One Pile → 추출 (What, When)
이 문서:     + 덜컥거림 감지 (How) - 어떻게 문제를 알아차리는가
            + 보폭 (How) - 추상화 레벨의 차이를 어떻게 감지하는가
            + 유창성 착각 (Why) - 왜 작성자는 문제를 못 느끼는가
```

이 문서는 켄트 벡의 이론적 토대 위에서, **발견의 감각을 어떻게 기르는가**를 구체화하려는 시도다.

---

## 왜 전환하는가

기존의 변화율 중심 설계 방법론에는 근본적인 문제가 있었다.

```
기존 방식:
변화율 분석 → 계층 설계 → 코드 작성

문제:
- "변화율을 분석했다. 그래서 뭘 해?"
- 분석 도구는 있는데 행동 전략이 없음
- 사전에 너무 많은 걸 고려해야 함
- 액션 빈도가 낮아짐
- 실제로 추상화를 발견하고 개선하는 경험이 쌓이지 않음
```

M, V, VI를 미리 나누고 시작하는 것, 인터페이스 격리 7단계를 처음부터 의식하고 들어가는 것, rate-of-change 분석을 코드 작성 전에 하는 것—이 모든 것이 "처음부터 무겁게 계층을 긋고 시작하는 것"이었다.

이 방식은 두 가지 실패를 낳는다:

1. **행동을 방해한다**: 빨리 펼쳐놓고 관찰을 통해 패턴을 발견할 기회를 차단한다.
2. **추상화에 실패한다**: 드러낼 건 드러내고 숨길 건 숨기는, 실제로 작동하는 추상화를 만들어내지 못한다.

---

## 새로운 사고방식: 펼쳐놓고 관찰하기

### 핵심 전환

```
기존: 분석 → 설계 → 코드
전환: 코드 → 관찰 → 추상화 → 검증
```

분석이 행동을 선행하는 게 아니라, 행동이 선행하고 분석은 검증 도구가 된다.

### 왜 펼쳐놓아야 하는가

패턴은 구체들이 뭉쳐있을 때만 보인다.

```tsx
// 펼쳐놓은 상태에서만 보이는 것
const expectedRevenue = monthlyAmount * savingsTerm * (1 + (rate / 100) * 0.5);
const recommendedAmount = targetAmount / (savingsTerm * (1 + (rate / 100) * 0.5));

// "어? 같은 공식이 두 번 나오네" ← 이 관찰이 추상화의 시작
```

미리 서랍에 나눠 넣으면 이 관찰 자체가 불가능해진다. 조금만 복잡해질 가능성이 보이면 다 쪼개버리거나, 통로로서의 props로 인터페이스를 만들어버리면, 본질이 드러나기 전에 이미 분해되어 숨겨진 상태가 된다.

### 통로로서의 Props vs 인터페이스로서의 Props

```tsx
// 통로로서의 Props - 모든 구현 세부사항이 드러남
<결제창
  카드={{
    신한: { 카드번호, 유효기간, CVC },
    삼성: { 카드번호, 유효기간, CVC },
  }}
  간편결제={{
    토스페이: { 토큰, 사용자키 },
    카카오페이: { 앱키, 리다이렉트URL },
  }}
/>

// 인터페이스로서의 Props - 본질만 드러남
<결제창 결제수단={토스페이} />
```

"카드/간편결제/계좌"로 묶은 건 분류지, 결제창이 필요로 하는 것(결제수단)을 발견한 게 아니다. 결제창 입장에서는 "신한카드든 토스페이든 나한테는 그냥 결제수단이야"인데, 초보자 버전은 여전히 모든 결제수단의 내부 사정을 결제창이 다 알고 있어야 한다.

---

## 행동 전략: 구체적인 단계들

### 1단계: 펼쳐놓기

UI와 1:1로 대응되도록 코드를 작성한다. 분리를 먼저 고민하지 않는다.

```tsx
function SavingsCalculatorPage() {
  const { data: products = [] } = useQuery(...);

  const [targetAmount, setTargetAmount] = useState(null);
  const [monthlyAmount, setMonthlyAmount] = useState(null);
  const [savingsTerm, setSavingsTerm] = useState(12);
  const [selectedProduct, setSelectedProduct] = useState(null);

  const filteredProducts = products.filter(...);
  const expectedRevenue = ...;
  const targetDifference = ...;
  const recommendedMonthlyAmount = ...;

  return (
    <>
      <TextField label="목표 금액" value={targetAmount} ... />
      <TextField label="월 납입액" value={monthlyAmount} ... />
      {/* ... 나머지 UI */}
    </>
  );
}
```

### 2단계: 덜컥거림 감지

코드를 읽을 때 뇌에서 일어나는 일:

```
1. 컴포넌트 이름을 읽는다 ("결제창")
2. 뇌가 자동으로 예측한다 ("다음엔 결제 관련 뭔가 나오겠지")
3. Props로 시선이 넘어간다
4-a. 기대와 일치하면 → 부드럽게 읽힘
4-b. 기대와 불일치하면 → 덜컥거림
```

```tsx
// 부드럽게 읽히는 경우
<결제창 결제수단={...} />
// "결제창" → "결제수단" → ✓ 예측이 맞았다

// 덜컥거리는 경우
<결제창 신한카드={...} />
// "결제창" → "신한카드" → ??? 보폭이 너무 넓다
```

이 "덜컥거림"이 추상화가 필요한 지점을 알려주는 신호다.

### 3단계: 패턴 발견

구체들을 늘어놓고 바라보면 공통점이 떠오른다.

```
신한카드, 토스페이, 네이버페이, 페이코...
→ "다 결제수단이네?"
```

이건 외부에서 주입되는 게 아니다. 패턴 인식은 인간의 기본적인 인지 능력이고, 구체들이 반복되는 사이에서 자연스럽게 떠오른다. 유니클로 후드티, 신발끈을 보고 "빨랫감"이라고 부르는 건 누가 가르쳐준 게 아니다.

### 4단계: 추출

패턴을 발견했다면, 추출 시점에 두 가지를 검증한다:

**검증 1: 우연의 일치인가, 본질적 동일인가?**

```tsx
// 우연의 일치 - 둘 다 문자열이지만 역할이 다름
const userName = "홍길동";
const productName = "적금 상품";

// 본질적 동일 - 결제창 입장에서 같은 역할
const 신한카드 = { process: () => ... };
const 토스페이 = { process: () => ... };
```

**검증 2: 추출한 것의 시그니처가 본질을 설명하는가?**

```tsx
// 시그니처가 본질을 말해주는 경우
<결제창 결제수단={토스페이} />
// "결제창은 결제수단을 받는다" ← 읽는 것만으로 역할이 보임

// 시그니처가 본질을 숨기는 경우
<결제창 data={...} config={...} options={...} />
// "결제창은... 뭘 하는 거지?" ← 해석이 필요함
```

---

## 덜컥거림의 감각: 어떻게 기르는가

### 유창성 착각의 함정

작성자는 덜컥거림을 못 느낀다.

```
작성자의 뇌:
"결제창"
    ↓
[단기기억: 방금 신한카드 연동 작업함, 토스페이도 붙였고...]
    ↓
"신한카드"
    ↓
"응, 맞아"
```

단기기억이 중간에서 자동으로 보완해준다. 보폭이 넓어도 덜컥거림을 못 느끼게 된다.

문제는: **단기기억은 휘발되고, 코드는 남는다.**

### 강제로 맥락을 제거하는 방법

| 방법                   | 효과                                 |
| ---------------------- | ------------------------------------ |
| 시간 두고 다시 보기    | 단기기억이 휘발된 후에 읽을 수 있다  |
| 다른 사람한테 보여주기 | 애초에 단기기억이 없는 사람이 읽는다 |
| 이름만 따로 나열해보기 | 맥락을 강제로 제거할 수 있다         |

### 실용적 셀프체크

1단계: 컴포넌트 이름과 props 이름만 뽑는다. 구현은 안 본다.

```
결제창
  - 신한카드
  - 토스페이
  - 국민계좌
```

2단계: 스스로 물어본다.

> "결제창이라는 이름을 보고, 다음에 신한카드가 나올 거라고 예측했을까?"

3단계: 판단한다.

- "응, 예측했어" → OK
- "아니, 예측 못 했어" → 보폭이 넓다 → 징검다리가 필요하다

### 좋은 레퍼런스: HTML

수십 년간 살아남은, 검증된 추상화들이다.

```html
<dialog>
  // "띄워서 보여준다" open={...} onClose={...}

  <input /> // "입력을 받는다" value={...} onChange={...}

  <form>// "모아서 보낸다" onSubmit={...}</form>
</dialog>
```

이름이 행위/역할을 말하고, props도 그 행위에 맞는 것들만 있다. 컴포넌트 이름과 props가 같은 언어로 말한다.

```
dialog (띄워서 보여준다)
  └─ open (열렸는지)
  └─ onClose (닫을 때)
→ 보폭이 좁다. 같은 추상화 레벨이다.

결제창 (???)
  └─ 신한카드
  └─ 토스페이
→ 보폭이 넓다. "결제창"이 뭘 하는 건지도 불분명하다.
```

---

## 변화율의 위치: 사후 검증 도구

### 기존의 오해

변화율 분석을 "사전 설계 도구"로 사용했다.

```
변화율 분석 → 이 코드는 자주 변할 것 → 미리 분리해두자
```

이건 행동 전략이 아니다. "분석했다, 그래서 뭘 해?"에 답이 없다.

### 새로운 위치

변화율은 **추상화의 품질을 검증하는 렌즈**다.

```
행동 전략:
1. 펼쳐놓는다
2. 덜컥거림을 감지한다
3. 패턴을 발견한다
4. 추출한다

검증 (여기서 변화율이 쓰임):
5. "이 추상화 경계에서 변경이 잘 막히는가?"
```

### 좋은 추상화는 변화율 문제를 자연스럽게 해결한다

```tsx
// 좋은 추상화
<결제창 결제수단={토스페이} />

// 왜 변화율 측면에서도 좋은가?
// - 새 결제수단 추가: 결제창 안 건드림 (결제수단 구현체만 추가)
// - 결제수단 내부 변경: 결제창 안 건드림 (구현체 내부만 변경)
// - 결제창 UI 변경: 결제수단들 안 건드림
```

변경의 경계가 추상화의 경계와 일치한다.

반대로:

```tsx
// 나쁜 추상화
<결제창 신한카드={{ 카드번호, 유효기간, CVC }} 토스페이={{ 토큰, 사용자키 }} />

// 왜 변화율 측면에서 나쁜가?
// - 새 결제수단 추가: 결제창 수정 필요
// - 결제수단 내부 변경: 결제창이 알아야 함
// - 변경이 경계를 넘어 전파됨
```

### 검증 방법

추출한 추상화에 대해 예상되는 변경들을 시뮬레이션한다:

1. 새 구현체 추가 → 기존 코드 수정 필요한가?
2. 구현체 내부 변경 → 사용하는 쪽에 영향 있나?
3. 사용하는 쪽 변경 → 구현체들에 영향 있나?

경계를 넘어 전파되면, 추상화가 잘못된 것이다.

---

## 추출의 도구 상자: FP/OOP 패턴의 위치

### 패턴은 추출 시점에 선택하는 도구

관찰을 통해 패턴을 발견했을 때, "이걸 어떻게 표현하지?"의 선택지들이다.

```
관찰: "이 계산 공식이 반복되네"
     ↓
선택지:
- 순수 함수로 추출 (FP)
- 클래스로 추출 (OOP)
- 훅으로 추출 (React)
```

이 단계에서는 긴장이 거의 없다. 도구 선택의 문제니까.

### 긴장이 생기는 지점

문제는 **패턴을 "미리 알고" 적용하려 할 때**다.

```
// 긴장 없음: 관찰 → 패턴 발견 → "어, 이거 Strategy 패턴이네"
// 긴장 있음: "여기 Strategy 패턴 쓰면 좋겠다" → 코드 작성
```

후자가 기존 변화율 중심 사고와 같은 함정이다. "분석했다, 패턴 알겠다, 그래서 뭘 해?"

### 예시: Strategy 패턴

```tsx
// 미리 적용하려는 경우
interface PaymentStrategy { process(): void; }
class CardPayment implements PaymentStrategy { ... }
class TossPayment implements PaymentStrategy { ... }

// 아직 결제수단이 2개밖에 없는데 이 구조를 만들어버림
// → 과도한 추상화, YAGNI 위반
```

```tsx
// 관찰 후 적용하는 경우

// 1. 펼쳐놓음
const processCard = () => { ... };
const processToss = () => { ... };
const processNaverPay = () => { ... };
const processPayco = () => { ... };

// 2. 관찰: "다 같은 시그니처네, process() 하나씩 있네"

// 3. 추출: "이거 Strategy 패턴이구나"
interface PaymentMethod { process(): void; }
```

### 도구 상자의 가치

패턴을 미리 아는 것 자체는 유용하다. 단, 그 용도가 다르다.

```
잘못된 용도: 사전 설계의 청사진
           "이 상황엔 이 패턴을 써야 해"

올바른 용도: 추출 시점의 어휘
           "이 관찰 결과를 표현할 언어가 있네"
```

Strategy, Observer, Factory 같은 패턴들을 알고 있으면, 관찰 결과를 더 빠르게 코드로 옮길 수 있다. 마치 "결제수단"이라는 단어를 알고 있으면 신한카드/토스페이의 공통점을 더 빠르게 명명할 수 있는 것처럼.

패턴은 **발견을 표현하는 언어**이지, **발견을 대체하는 규칙**이 아니다.

---

## 정리: 행동 전략

```
1. 펼쳐놓기
   - UI와 1:1로 대응되게 코드를 작성한다
   - 분리를 먼저 고민하지 않는다

2. 덜컥거림 감지
   - 이름을 읽고, 다음에 뭐가 나올지 예측하고, 실제와 비교한다
   - 예측과 다르면 → 보폭이 넓다 → 징검다리가 필요하다

3. 패턴 발견
   - 구체들을 늘어놓고 바라본다
   - 공통점이 떠오를 때까지 기다린다 (만드는 게 아니라 발견하는 것)

4. 추출
   - 우연의 일치 vs 본질적 동일 검증
   - 시그니처가 본질을 설명하는지 검증

5. 변화율로 검증
   - 예상 변경을 시뮬레이션
   - 경계를 넘어 전파되면 추상화 재검토
```

---

## 열린 질문과 현재의 생각

### 1. 변화율 관점과 추상화 관점의 완전한 통합

**질문**: 좋은 추상화가 항상 변화율 문제를 해결하는가? 아니면 긴장이 존재하는 케이스가 있는가?

**현재의 생각**: 좋은 추상화가 변화율 문제를 대부분 해결한다. 단, 방향이 중요하다.

```
추상화 → 변화율 (자연스럽게 따라옴)
변화율 → 추상화 (행동 전략 부재)
```

좋은 추상화는 "관심사의 경계"를 잘 긋는 것이다. 그리고 변경은 대부분 관심사 단위로 일어난다.

```tsx
<결제창 결제수단={토스페이} />
```

이 추상화가 좋은 이유는 "결제창의 관심사"와 "결제수단의 관심사"를 분리했기 때문이다. 그리고 변경도 이 경계를 따라 일어난다.

**긴장이 존재하는 케이스가 있는가?**

있을 수 있다. 예를 들어:

```tsx
// 좋은 추상화: 읽기 쉽고, 사용하기 쉬움
<DatePicker value={date} onChange={setDate} />

// 그런데 요구사항: "이 화면에서만 특수한 달력 UI를 써야 해"
// 추상화 경계를 깨야 함
```

하지만 이건 추상화가 잘못된 게 아니라, 요구사항이 추상화의 범위를 벗어난 것이다. 이 경우 선택지는:

- 추상화를 확장하거나
- 이 케이스는 추상화 밖에서 처리하거나

결국 **추상화의 범위를 잘 잡는 것**이 관건이고, 이건 관찰을 통해서만 알 수 있다.

---

### 2. 추상화와 유지보수성의 관계

**질문**: 추상화("이해하기 쉬운가? 사용하기 쉬운가?")와 유지보수성("변경하기 쉬운가?")은 항상 같이 다니는가, 아니면 긴장이 존재하는가?

**현재의 생각**: 같은 것의 다른 표현에 가깝다. 단, 시간 축이 다르다.

```
추상화: "지금" 이해하기 쉬운가? 사용하기 쉬운가?
유지보수성: "나중에" 변경하기 쉬운가?
```

긴장이 생기는 것처럼 보이는 케이스:

```tsx
// Case A: 추상화 높음, 유지보수성 낮음?
<MagicButton />  // 내부에서 모든 걸 알아서 함
// 사용하기 쉬움, 근데 변경하려면 내부를 다 뜯어야 함

// Case B: 추상화 낮음, 유지보수성 높음?
<Button onClick={...} style={...} disabled={...} loading={...} />
// 모든 게 드러나 있음, 변경 지점이 명확함
```

하지만 **Case A는 좋은 추상화가 아니다.** "숨길 건 숨기고 드러낼 건 드러내는" 원칙을 어겼기 때문이다. 모든 걸 숨긴 건 추상화가 아니라 은닉이다.

**좋은 추상화의 정의를 다시 보면:**

```
드러낼 것: 사용자가 알아야 하는 것 (인터페이스)
숨길 것: 사용자가 몰라도 되는 것 (구현)
```

이 경계를 잘 그으면, 이해하기도 쉽고 변경하기도 쉽다. 변경 지점이 인터페이스인지 구현인지 명확하니까.

**결론: 긴장은 "잘못된 추상화"에서 오는 것이지, 추상화와 유지보수성 사이의 본질적 긴장이 아니다.**

---

### 3. 기존 방법론들의 재배치

**질문**: MV-VI 패턴, 인터페이스 격리 7단계 등이 "사전 설계"가 아니라 "사후 정리"의 도구가 될 수 있는가?

**현재의 생각**: 사전 설계가 아니라, 관찰 결과를 정리하는 프레임워크로 쓸 수 있다.

#### MV-VI 패턴

```
기존 용도: "M, V, VI로 나눠서 설계하자"

재배치 후: 펼쳐놓고 관찰했더니, 이런 패턴이 보이네
          - 이건 도메인 인터페이스네 (M)
          - 이건 순수한 뷰네 (V)
          - 이건 런타임 복잡도를 흡수하네 (VI)
```

MV-VI는 **관찰 결과를 분류하는 언어**가 될 수 있다. "이 코드는 M인가 V인가 VI인가?"라고 물으면, 책임이 명확해지는지 확인하는 렌즈가 된다.

#### 인터페이스 격리 7단계

```
기존 용도: 1단계부터 순서대로 따라가기

재배치 후: 추출하려고 보니, 이 단계들이 필요하네
          - 메서드 추출이 필요하네 (몇 단계)
          - 협상이 필요하네 (몇 단계)
```

7단계 전체를 사전에 의식하는 게 아니라, **추출 과정에서 막힐 때 참조하는 체크리스트**로 쓸 수 있다.

#### 방법론 재배치 정리

| 방법론          | 기존 용도         | 재배치 후               |
| --------------- | ----------------- | ----------------------- |
| MV-VI           | 사전 설계 구조    | 관찰 결과 분류 언어     |
| 인터페이스 격리 | 순서대로 따라가기 | 추출 시 참조 체크리스트 |
| 변화율 분석     | 사전 분석 도구    | 사후 검증 렌즈          |
| FP/OOP 패턴     | 적용할 규칙       | 발견을 표현하는 언어    |

---

이 문서는 완성된 방법론이 아니라, 탐구 중인 사고방식이다. 행동을 통해 계속 검증하고 발전시켜 나갈 것이다.

#### 추상화에서 무엇을 드러내고(what-핵심) 무엇을 숨길 까(how-세부사항)

기획서의 아이디어가 1:1 대응 하는 과정에서 무엇이 드러나야 할 지 무엇이 숨겨져야 할지가 드러난다.

UI와 코드가 1:1 -> UI 컴포넌트에 대한 요구사항
기획서와 코드가 1:1 -> 로직에 대한 요구사항

기획서 대로 기능과 UI를 펼쳐서 구현하고
기획서와 구현된 코드를 번갈아 보면서 기획에서 what을 발견하고 코드를 보면서 what과 how을 분류해야 한다.
기획서에서의 컴포넌트 단위를 보면서 이 컴포넌트의 본질을 파악해야 하는데, 본질을 파악하기 위해서는 그 본질의 구성요소들을 분해해 봐야 한다.그 과정에서 그게 진짜 본질일까? 를 질문하게 될 수도 있다. 그리고 그 결론에 복잡한 것들에서 what과 how가 분류되면서 복잡성이 낮아진다.
what과 how를 구분할 때는 소거 법이 유용할 수 있다. 소거를 하면서 소거에 따라서 본질이 해치는 지 확인한다.
집착해야 할 건 분리를 어떻게 해야 할까가 아니라 what이 무엇일까에 대한 답이다.
