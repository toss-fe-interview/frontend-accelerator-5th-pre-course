# 개요

💰 토스 적금 계산기 (Pre-Course 과제)

서비스의 유지보수나 장기적인 확장성을 고려한 설계, 추상화 관점에 집중해서 기능을 구현 신경써서 개발하기

## 설계 의도

**1. 기능 기반 구조 (Feature-based Structure)**

- 관련 코드를 한 곳에 모아 수정 시 파일 탐색 비용을 줄이기 위해 기능 기반 구조를 선택
- 관련 코드(컴포넌트, 훅, 타입)를 기능 단위로 응집
- 파일 탐색 시 이동 거리 최소화: 하나의 기능 수정 시 `features/savings-calculator` 내에서 대부분 해결
- `shared` 폴더에는 여러 기능에서 공유되는 타입, 유틸, API 훅만 배치

**2. 데이터 페칭 분리 (TanStack Query + Custom Hook)**

- 캐싱/재요청 로직을 TanStack Query에 위임
- Page 컴포넌트는 상태 관리와 렌더링에만 집중
- Query Key를 `shared/constants`에서 중앙 관리하여 캐시 무효화 시 일관성 보장

## 유지보수성과 확장성에 대한 관점

추상화의 적정선을 찾는 것이 핵심이라고 생각합니다.

너무 이르면 불필요한 복잡도가, 너무 늦으면 중복과 결합이 쌓이는데 이 프로젝트에서는 "두 번째 사용처가 생기거나, 책임이 비대해질 때" 추상화하는 것을 기준으로 삼았습니다.

단, API 페칭 훅이나 공통 타입처럼 여러 기능에서 공유될 가능성이 높은 코드는 장기적인 확장성을 고려해 `shared`에 미리 배치했습니다

## 고민사항

두 기능에서 동일한 코드가 필요해졌을 때가 위에서 적정선이라고 적긴했지만 바로 shared로 올릴지 기능 간 import를 허용할지 기준이 모호합니다. 전자는 구조적 일관성을, 후자는 이동 비용 절약을 택하는 건데, 어느 시점에 어떤 선택이 적절한지 판단이 어렵습니다

입력 필드에서 useState vs react-hook-form 도입 시점과 기준

컴포넌트를 세분화할수록 props drilling이 깊어지는데, Context 도입 없이 허용할 수 있는 적정선이 어디인지 고민됩니다. 저는 3단계 정도는 명시적이라 괜찮지만, 그 이상이 되면 중간 컴포넌트가 "전달자" 역할만 하게 될 것 같은데 의견이 궁금합니다

- 래처럼 반복되는 컴포넌트가 있을 때, 개수가 적으면(4~5개 이하) map보다 명시적으로 나열하는 게 가독성이 좋다고 생각하는데 map을 도입하는 기준이 있는지 궁금합니다.

```jsx
<SelectBottomSheet.Option value={6}>6개월</SelectBottomSheet.Option>
<SelectBottomSheet.Option value={12}>12개월</SelectBottomSheet.Option>
<SelectBottomSheet.Option value={24}>24개월</SelectBottomSheet.Option>
```

추상화 수준이나 확장성 설계에 정답은 없다고 생각하는데, 종택님은 이런 트레이드오프를 어떻게 판단하시는지 기준이 궁금합니다.

## 추가 구현 필요한 것

적금 상품 API 호출 시 로딩 스피너 및 에러 메시지 표시

월 납입액 조건에 맞는 상품이 없을 때 가장 근접한 상품 추천

목표 금액과 월 납입액을 입력하지 않았을 때 계산 결과 화면

## 클린코드

- 실무에서 클린코드란 유지보수 시간의 단축 -> 코드파악, 디버깅, 리뷰에 쓰이는 시간 단축됨
- 클린 코드는 짧은 코드가 아니라 원하는 로직을 빠르게 찾을 수 있는 코드
  - 하나의 목적을 가진 코드가 흩뿌려져 있음 -> 응집도를 가져야함
    - useState, 핸들러 함수, 컴포넌트를 커스텀 훅으로 한군데에 뭉쳐 한 파일에서 보기 쉽게함
    - 그런데 커스텀 훅을 불러오는 곳에서는 훅만 보고 어떤 기능을 하는지 알 수 없음
    - -> 무조건 응집도 x / 당장 몰라도 되는 디테일은 뭉치면 좋고 코드 파악에 필수적인 핵심 정보는 뭉치면 안좋음 -> 남겨야할 것과 숨겨도 될 것을 나눠야함
  - 함수가 여러가지 일을 함 -> 단일책임을 가진 함수로 변경
  - 함수의 세부구현 단계가 제각각 -> 추상화해서 핵심개념을 필요한 만큼만 노출해야한다.
  - 상수를 직관적으로 보고 싶거나 영어이름이 복잡해 질 때 한글 변수도 유용함

### 선언적 프로그래밍 (무엇을 해야할지 알려줘, 세부구현은 다 했어)

- 핵심 데이터만 전달받고 세부 구현은 뭉쳐 숨겨 두는 개발 스타일
- 세부 구현은 안쪽에 뭉쳐두어서 신경쓸 필요 없고, 무엇만 바꿔서 쉽게 재사용 할 수 있음
- 명령형 프로그래밍과 유동적으로 사용

### 추상화

- 로직에서 핵심 개념 뽑아내기

```jsx
// 팝업 코드를 제로부터 구현

<div style={}>
    <button onClick={
        async ()=>{
            const res = await 회원가입();
            if(res.success){
                프로필로이동();
            }
        }
    }>
        전송
    </button>
</div>

// 중요 개념만 남기고 추상화
<Popup
    onSubmit={회원가입}
    onSuccess={프로필로 이동}
 />

// 설계사의 라벨을 얻는 세부 구현
const planner = await 플래너(아이디);
const label = 플래너.뉴 ? '새로운 상담사' : '연결중인 상담사'

// 중요 개념을 함수 이름에 담아 추상화
const label = await getPlannerLabel(아이디)

```

#### 얼마나 추상화 할 것인가?

- level 0 구체적인 코드

```jsx
<Button onClick={showConfirm}>
전송
</Button>
{isShowConfirm && (
    <Confirm onClick = {()=>{showMessage('성공')}}>
)}
```

- level 1 버튼 눌렀을때 컨펌창 띄우는 기능을 컨펌버튼이라는 컴포넌트로 추상화

```jsx
<ConfirmButton
  onConfirm={() => {
    showMessage('성공');
  }}
>
  전송
</ConfirmButton>
```

- level 2 message라는 props만 넘길수록 더 간단하게 추상화 가능

```jsx
<ConfirmButton message="성공">전송</ConfirmButton>
```

#### 정답은 없다 필요한 만큼 추상화하도록

#### 추상화 수준은 동일하게 해야함 섞여 있으면 코드 파악이 어렵다

#### 기존 코드 뜯어보는거 두려워 하지말고 담대하게 수정해보자

#### 코드에 정답은 없다 팀과 명시적으로 이야기하는 시간 필요함

#### 문서로 적어서 명확하게 하기(향후 어떤 점에서 위험한지, 어떻게 개선할 수 있는지)

## 디스코드

- 빠르게 시도하고 -> 전문가에게 피드백 받고 -> 이전보다 더 똑똑해진 상태에서 빠르게 더 나은 다음 시도를 하는 사이클을 돌자
- 피드백 사이클을 거치면서 나의 사고과정이 전문가의 그것에 점점 더 가까워 지는게 목적이라고 동의할 수 있다면 나의 사고과정을 최대한 드러내놓고, 전문가의 사고과정을 최대한 그대로 드러내놓는게 일단 필요하다
  현재 리뷰어는 **"코드는 비즈니스와 UI의 거울이어야 하며, 섣부른 추상화(분리)는 오히려 독이 된다"**는 철학을 가지고 있습니다.

이 내용을 이해하기 쉽게 3가지 핵심 축으로 나누어 상세히 설명해 드리겠습니다.

1. 핵심 철학: 좋은 코드란 "예측 가능한 코드"다
   리뷰어는 '깔끔한 코드'보다 **'변경하기 쉬운 코드'**를 원합니다.

변경의 기준: 개발자가 임의로 정한 논리가 아니라, 비즈니스 요구사항(기획서)과 UI가 기준이 되어야 합니다.

목표: 기획자가 "UI의 이 부분을 바꿔주세요"라고 했을 때, 개발자가 코드의 어느 부분을 고쳐야 할지 즉시 알 수 있어야 합니다.

🔍 핵심 1: UI와 코드의 1:1 대응 (The Mapping)
개념: 화면(UI)에 보이는 덩어리와 코드의 컴포넌트 덩어리가 정확히 일치해야 합니다.

나쁜 예: 화면에는 '적금 입력창'이 하나인데, 코드에서는 InputWrapper, DataHandler, LayoutContainer 등으로 파편화되어 있어 로직을 찾기 힘든 경우.

좋은 예: 화면에 SavingsInput이 보이면, 코드에도 SavingsInput 컴포넌트가 있고 그 안에 관련 로직이 다 들어있는 경우.

액션 아이템: 컴포넌트 이름을 지을 때, 기능(Function)이 아니라 화면(UI)의 역할을 따르세요.

2. 경계의 설정: "일단 분리"는 금물 (The Cost)
   많은 주니어 개발자가 "파일을 잘게 쪼개는 것 = 좋은 설계"라고 착각합니다. 리뷰어는 이를 **"시점 이동 비용(Context Switching Cost)"**이라는 개념으로 반박합니다.

시점 이동 비용이란?

코드를 읽다가 다른 파일을 열어야 함 (물리적 비용)

"아까 그 변수가 뭐였지?" 다시 기억해야 함 (인지적 비용)

"이 함수는 아마 이렇게 동작하겠지?" 예측해야 함 (불확실성)

리뷰어의 메시지: "분리해서 얻는 이득(재사용성, 명확성)이 이 비용보다 크지 않다면, 차라리 분리하지 말고 한 파일에 두는 게 낫다."

🔍 핵심 2: 분리 ≠ 해결
함수를 쪼갠다고 복잡한 로직이 사라지는 게 아닙니다. 그냥 다른 파일로 숨기는 것일 뿐입니다.

액션 아이템: 함수나 컴포넌트를 분리하기 전에 자문하세요. "이걸 분리해서 내가 얻는 게 뭐지? 그냥 코드가 길어서 쪼개는 건가?" 만약 이유가 명확하지 않다면 다시 합치세요(Inline).

3. 방법론: 밖에서 안으로 vs 안에서 밖으로 (The Direction)
   이 부분이 가장 실천적인 조언입니다. 추상화를 하는 순서를 바꾸라는 것입니다.

❌ 밖에서 안으로 (Outside-In / Top-Down):

"일단 Header, Body, Footer로 나누고, 데이터는 Hook으로 빼야지." (구조를 먼저 잡음)

문제점: 나중에 구현하다 보면 데이터가 꼬이고, props 구멍 파기(drilling)가 발생하며, 구조가 어색해집니다.

✅ 안에서 밖으로 (Inside-Out / Bottom-Up) [추천]:

Step 1: 일단 하나의 파일(Page 등)에 모든 로직과 UI를 다 때려 넣으세요. (Inline)

Step 2: 코드를 작성하다 보면 자연스럽게 **함께 뭉쳐 다니는 데이터와 로직(패턴)**이 보입니다.

Step 3: 그 "발견된 패턴"만 떼어내서 함수나 컴포넌트로 분리합니다.

장점: 이렇게 분리하면 경계가 아주 자연스럽고 명확합니다.

4. 리뷰어의 질문 의도 파악하기 (Review Patterns)
   리뷰어가 계속 질문을 던지는 이유는 정답을 몰라서가 아니라, **작성자의 생각(Mental Model)**을 듣고 교정해주기 위해서입니다.

"추상화를 어떻게 정의하시나요?"

👉 용어 정리부터 다시 하자는 뜻입니다. (작성자가 생각하는 추상화가 그냥 '파일 쪼개기'인지 확인)

"그렇게 하면 무엇을 얻고 무엇을 잃나요?" (트레이드오프)

👉 분리에는 반드시 비용(단점)이 따르는데, 그걸 인지하고 결정했는지 묻는 것입니다.

"실제 코드와 매핑해보고 싶습니다."

👉 말로만 그럴듯한 이론을 펼치지 말고, 그 이론이 본인 코드 어디에 적용됐는지 증명하라는 뜻입니다.

🚀 지금 당장 해야 할 일 (Action Plan)
담당자의 리뷰에 답변하거나 코드를 수정할 때 다음 단계를 따라보세요.

일단 합치세요 (Inline): 과도하게 분리된 컴포넌트나 훅이 있다면, 사용하는 곳으로 코드를 다시 가져와서 합쳐보세요.

이름표 다시 붙이기: 컴포넌트나 함수 이름이 UI/기획서의 용어와 일치하는지 확인하세요. (개발자만 아는 용어 금지)

자연스러운 경계 찾기: 합쳐진 코드 덩어리에서 "정말 뗄 수밖에 없는 명확한 이유"가 있는 부분만 다시 살짝 떼어내세요.

답변 준비: 리뷰어에게 "처음엔 A 구조로 분리했으나, 시점 이동 비용이 더 크다고 판단하여 B 화면 단위로 다시 응집시켰습니다"와 같이 **판단의 근거(Trade-off)**를 제시하세요.

이 리뷰 과정은 단순히 코드를 고치는 게 아니라, "설계를 바라보는 눈"을 업그레이드하는 과정입니다. 이 기회를 잘 활용하시면 실력이 크게 성장할 것입니다.
